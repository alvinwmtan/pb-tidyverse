---
title:  "Peekbank Hackathon: Tidyverse Refresher"
author: "Alvin Tan"
date:   "2024-08-26"
format: html
---

In this session, we will provide a quick refresher on data wrangling with the `tidyverse` package. 

```{r install, eval=F}
# run this only once to install tidyverse
install.packages("tidyverse")
```

```{r setup}
library(tidyverse)
```

# R + Markdown

This document is a Quarto Markdown document (similar to an R Markdown document); it contains text (like this), as well as code blocks, which are indicated by three backticks and the type of code in braces:

```{r}
# This is a code block!
```

QMD/RMD documents are really good for reproducible analysis and documentation: they allow you to include both text and code in the same place, so you don't have to generate a plot in one piece of software and copy it somewhere else where your text lives, which is very prone to error (e.g., you updated a part of your analysis pipeline... but forgot to copy one of the new plots back).
It also allows other collaborators to read and understand your code, and how it fits in with the overall structure of the document (rather than having to constantly cross-refer from the manuscript to the code).

A few basic tips and tricks when working with QMD/RMD documents:
* The stuff at the very top of the document is its YAML header, which contains basic information about the document. (Don't mess with this mostly). 
* For code blocks, the grey down triangle with a green bar means "run all previous code chunks", and the green right triangle (or Cmd/Ctrl+Shift+Enter) means "run this code chunk".
* You can knit/render the document (via a button on the toolbar, or Cmd/Ctrl+Shift+K) to generate a rendered HTML/PDF/DOCX file (useful for quickly sharing some analysis, or for various manuscript submissions).

# `tidyverse` refresher

We will assume that you already have some familiarity with R, but just as a quick refresher, we will go through a few of the key aspects of the `tidyverse` that we will use.

The best reference for this material is Hadley Wickham's [R for Data Scientists](http://r4ds.had.co.nz/) and we encourage you to read it if you are interested in learning more. 

## Tidy data

The basic data structure we're working with is the dataframe (or `tibble` in the `tidyverse` implementation).

Dataframes have rows and columns, and each column has a particular data type. 
For a dataframe to be **tidy**, every row must record a single **observation**, while every column must describe a single **variable**, such that each cell is a single **value**.

> “Tidy datasets are all alike, but every messy dataset is messy in its own way.” –– Hadley Wickham

This consistency allows us to adopt a uniform approach to handling the data, and to make use of powerful tools that R and the `tidyverse` contain.

## Data wrangling

Once we have tidy data, we can manipulate them using some of the functions in the `tidyverse`.

To illustrate some of these functions (or "verbs"), we will use a cached subset of the looking-while-listening data from Adams et al. ([2018](https://doi.org/10.1111/cdev.12818)).
This study aimed to investigate the role of caregiver talk in predicting children's language abilities for full-term and pre-term children.
These children were tested at 16 and 18 months of age with a set of measures including the looking-while-listening task, which was intended as a measure of real-time language comprehension.

We can take a peek at what's in the data by using the `head` function. 

```{r}
et_data <- read_csv("adams_et_data.csv")
head(et_data)
```

```{r}
admin_data <- read_csv("adams_admin_data.csv")
head(admin_data)
```

The first file contains the eye-tracking data, which reflect which area of interest (AOI) the child is looking at for any given moment. 
The second file contains more general information about each administration, including the age and sex of the child.

We can also have a quick overview of the data by using the `summary` function.

```{r}
summary(et_data)
```

Alternatively, if we want an overview of just one categorical variable, we can use the `count` function.

```{r}
count(admin_data, sex)
```

**EXERCISE:** How many infants completed all four measurements (as planned)? How many completed only two or three?

```{r}
# your code here:

```


We can extract rows that fulfill some condition by using the `filter` function. 
This is useful when we want to select a subpopulation, or to exclude outliers, etc.
For example, we can include only 18-month-olds.

```{r}
filter(admin_data, age == 18)
```

We can construct new variables using the `mutate` function, perhaps to compute a derived value. 
For example, we might want to split up the ages into age bins.

```{r}
mutate(admin_data, age_bin = cut(age, c(13, 15, 17, 19, 21)))
```

We can also find a summary of the data at the level of some grouping variable (e.g., participant, age groups, sex). 
To do this, we can use `group_by` to define the groups, and `summarise` to *apply a function* to each group separately. 
For example, we can group the eye-tracking data by administration ID, and find the looking time towards the target and the distractor respectively.

```{r}
et_data |> 
  group_by(administration_id) |> 
  summarise(looks_target = sum(aoi == "target"),
            looks_distractor = sum(aoi == "distractor"),
            looks_total = n())
```

Notice here that we've also used the pipe, `|>` (or `%>%`).
What this does is put the left-hand value into the first argument of the right-hand function.
This allows us to chain functions together easily---first applying the `group_by`, then the `summarise`.
This works because almost all verbs in the `tidyverse` take in a dataframe as their first argument, and return another dataframe, so you can pipe them together easily.

**EXERCISE:** First, filter the eye-tracking data to only the 300 to 4000ms window (using the variable `t_norm`).
Then, calculate the _proportion_ looking towards the target for each administration, excluding looks to any AOI other than the target or distractor.

```{r}
# your code here:

```

## Visualisation

Visualisation in the `tidyverse` is handled by `ggplot2` (short for "grammar of graphics").
We use the function `ggplot` to initialise a plot, and various `geom`s to construct and display data on the plot.
For example, we may want to show the relationship between time and looking towards the target.

To do so, we first need to transform the data so that the plot is meaningful. 
Here, we convert "target" to 1 and "distractor" to 0, and all other values for AOI to NA.
Notice that we use the assignment operator `<-` to save the output of our data processing to a new variable.

```{r}
et_data_plot <- et_data |> 
  mutate(aoi = case_when(
    aoi == "target" ~ 1,
    aoi == "distractor" ~ 0,
    .default = NA
  ))
```


```{r}
ggplot(data = et_data_plot |> filter(!is.na(aoi)),
       mapping = aes(x = t_norm, y = aoi)) +
  geom_point(alpha = .01) +
  stat_summary(geom = "line", fun = mean)
```

**EXERCISE:** Make this plot prettier!
Some things you might want to do:
- Change the axis labels so they're more interpretable (using `labs`)
- Change the colour of the plotted line so it stands out more
- Jitter the points so we can see the density better (using `geom_jitter`—but we only want jitter in height!)
- Add a line at y = 0.5 (i.e., when looking is at chance)
- Change the theme (e.g., to `theme_classic`)

```{r}
# your code here:

```
